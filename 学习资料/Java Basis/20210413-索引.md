

##★ 二叉查找树  AVL Tree B-Tree  B+Tree

https://blog.csdn.net/hao65103940/article/details/89032538
###二叉查找树：遇到这样的数据会慢

![](https://img-blog.csdn.net/20160202203448944)

##AVL Tree 树中进行插入或删除节点，可能导致AVL树失去平衡
，这种失去平衡的二叉树可以概括为四种姿态：LL（左左）、RR（右右）、LR（左右）、RL（右左）。它们的示意图如下： 
![](https://img-blog.csdn.net/20160202203648148)

##平衡多路查找树（B-Tree）
B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。

**系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。
而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。
B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。**

一棵m阶的B-Tree有如下特性： 

1. 每个节点最多有m个孩子。 
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 
3. 若根节点不是叶子节点，则至少有2个孩子 
4. 所有叶子节点都在同一层，且不包含其它关键字信息 
5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 
6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 
7. ki(i=1,…n)为关键字，且关键字升序排序。 
8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree： 
索引

![](https://img-blog.csdn.net/20160202204827368)


每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。

模拟查找关键字29的过程：

根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】
比较关键字29在区间（17,35），找到磁盘块1的指针P2。
根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】
比较关键字29在区间（26,30），找到磁盘块3的指针P2。
根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】
在磁盘块8中的关键字列表中找到关键字29。
分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。

##B+Tree
B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。

从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。**而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数,进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。**

B+Tree相对于B-Tree有几点不同：

- 	非叶子节点只存储键值信息。
- 	所有叶子节点之间都有一个链指针。
- 	数据记录都存放在叶子节点中。


将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示： 

![](https://img-blog.csdn.net/20160202205105560)

通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。

可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：

InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。

实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。

数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。




数据库索引（Oracle和MySql）
索引概念

索引是关系数据库中用于存放每一条记录的一种对象，主要目的是加快数据的读取速度和完整性检查。建立索引是一项技术性要求高的工作。一般在数据库设计阶段得与数据库结构一起考虑。应用系统的性能直接与索引的合理直接有关。

一.Oracle索引

1.索引类型

1）非唯一索引（最常用）UonUnique。

2）唯一索引Unique。

3）位图索引Bitmap

4）分区索引Partitioned

5）非分区索引NonPartitioned

6）正常型B树Normal

7）基于函数的索引Function-based

2.索引结构

1）B-tree：

适合与大量的增、删、改（OLTP）； 

不能用包含OR操作符的查询； 

适合高基数的列（唯一值多） 

2）典型的树状结构； 

每个结点都是数据块； 

大多都是物理上一层、两层或三层不定，逻辑上三层； 

叶子块数据是排序的，从左向右递增； 

在分支块和根块中放的是索引的范围；

3）Bitmap:

适合与决策支持系统； 

做UPDATE代价非常高； 

非常适合OR操作符的查询； 

基数比较少的时候才能建位图索引；

4）树型结构：

<1>索引头 

开始ROWID，结束ROWID（先列出索引的最大范围）

<2>BITMAP

每一个BIT对应着一个ROWID，它的值是1还是0，如果是1，表示着BIT对应的ROWID有值

5）b-tree索引

Oracle数据库中最常见的索引类型是b-tree索引，也就是B-树索引，以其同名的计算科学结构命名。CREATE INDEX语句时，默认就是在创建b-tree索引。没有特别规定可用于任何情况。

6）位图索引(bitmap index)

位图索引特定于该列只有几个枚举值的情况，比如性别字段，标示字段比如只有0和1的情况。

7）基于函数的索引

比如经常对某个字段做查询的时候是带函数操作的，那么此时建一个函数索引就有价值了。

8）分区索引和全局索引

这2个是用于分区表的时候。前者是分区内索引，后者是全表索引

9）反向索引（REVERSE）

这个索引不常见，但是特定情况特别有效，比如一个varchar(5)位字段(员工编号)含值（10001,10002,10033,10005,10016..） 

这种情况默认索引分布过于密集，不能利用好服务器的并行 

但是反向之后10001,20001,33001,50001,61001就有了一个很好的分布，能高效的利用好并行运算。

10）HASH索引

HASH索引可能是访问数据库中数据的最快方法，但它也有自身的缺点。集群键上不同值的数目必须在创建HASH集群之前就要知道。需要在创建HASH集群的时候指定这个值。使用HASH索引必须要使用HASH集群。

3.索引原理

若没有索引，搜索某个记录时（例如查找name='wish'）需要搜索所有的记录，因为不能保证只有一个wish，必须全部搜索一遍

若在name上建立索引，oracle会对全表进行一次搜索，将每条记录的name值哪找升序排列，然后构建索引条目（name和rowid），存储到索引段中，查询name为wish时即可直接查找对应地方

创建了索引并不一定就会使用，oracle自动统计表的信息后，决定是否使用索引，表中数据很少时使用全表扫描速度已经很快，没有必要使用索引

4.建立索引的原则

1）如果有两个或者以上的索引，其中有一个唯一性索引，而其他是非唯一，这种情况下oracle将使用唯一性索引而完全忽略非唯一性索引

2）至少要包含组合索引的第一列（即如果索引建立在多个列上，只有它的第一个列被where子句引用时，优化器才会使用该索引）

3）小表不要简历索引

4）对于基数大的列适合建立B树索引，对于基数小的列适合简历位图索引

5）列中有很多空值，但经常查询该列上非空记录时应该建立索引

6）经常进行连接查询的列应该创建索引

7）使用create index时要将最常查询的列放在最前面

8）LONG（可变长字符串数据，最长2G）和LONG RAW（可变长二进制数据，最长2G）列不能创建索引

9）限制表中索引的数量（创建索引耗费时间，并且随数据量的增大而增大；索引会占用物理空间；当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度）

5.索引使用原则

1）经常检索排序大表中40%或非排序表7%的行，建议建索引；

2）为了改善多表关联，索引列用于联结；

3）列中的值相对比较唯一；

4）取值范围（大：B*树索引，小：位图索引）；

5）Date型列一般适合基于函数的索引；

6）列中有许多空值，不适合建立索引

二.MySql索引

1.索引类型

1）单列索引(普通索引，唯一索引，主键索引)、组合索引、全文索引、空间索引

2）单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。

3）普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。

4）唯一索引：索引列中的值必须是唯一的，但是允许为空值。

5）主键索引：是一种特殊的唯一索引，不允许有空值。

6）组合索引：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。这个如果还不明白，等后面举例讲解时在细说　
7）全文索引：只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有"你是个大煞笔，二货 ..." 通过大煞笔，可能就可以找到该条记录。这里说的是可能，因为全文索引的使用涉及了很多细节，我们只需要知道这个大概意思，如果感兴趣进一步深入使用它，那么看下面测试该索引时，会给出一个博文，供大家参考。

8）空间索引：空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。在创建空间索引时，使用SPATIAL关键字。要求，引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。

2.索引原理

在MySQL中，存储引擎用类似的方法使用索引，其先在索引中查找对应的值，然后根据匹配的索引记录找到对应的数据行，最后将数据结果集返回给客户端。

3.索引使用原则

最左前缀匹配原则

mysql会一直向右匹配直到遇到范围查询（>、<、between、like）就停止匹配。比如a = 1 and b = 2 and c > 3 and d = 4，如果建立（a,b,c,d）顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

=和in可以乱序

比如a = 1 and b = 2 and c = 3 建立（a,b,c）索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

尽量选择区分度高的列作为索引

区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。

索引列不能参与计算，保持列“干净”

比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);

尽量的扩展索引，不要新建索引

比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

4.高性能索引列

独立的列

前缀索引和索引的选择性

多列索引

选择合适的索引列顺序

聚簇索引

覆盖索引

使用索引扫描来做排序

冗余和重复索引

未使用的索引


##B-Tree
就是我们常说的B树，一定不要读成B减树，否则就很丢人了。B树这种数据结构常常用于实现数据库索引，因为它的查找效率比较高。

https://blog.csdn.net/sinat_27602945/article/details/80118362

磁盘IO与预读
磁盘读取依靠的是机械运动，分为寻道时间、旋转延迟、传输时间三个部分，这三个部分耗时相加就是一次磁盘IO的时间，大概9ms左右。这个成本是访问内存的十万倍左右；正是由于磁盘IO是非常昂贵的操作，所以计算机操作系统对此做了优化：预读；每一次IO时，不仅仅把当前磁盘地址的数据加载到内存，同时也把相邻数据也加载到内存缓冲区中。因为局部预读原理说明：当访问一个地址数据的时候，与其相邻的数据很快也会被访问到。每次磁盘IO读取的数据我们称之为一页（page）。一页的大小与操作系统有关，一般为4k或者8k。这也就意味着读取一页内数据的时候，实际上发生了一次磁盘IO。

二、B-Tree
m阶B-Tree满足以下条件：

1、每个节点最多拥有m个子树

2、根节点至少有2个子树

3、分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）

4、所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列

 如下有一个3阶的B树，观察查找元素21的过程：
第一次磁盘IO：   
第二次磁盘IO：
这里有一次内存比对：分别跟3与12比对
第三次磁盘IO:
这里有一次内存比对，分别跟14与21比对
从查找过程中发现，B树的比对次数和磁盘IO的次数与二叉树相差不了多少，所以这样看来并没有什么优势。
但是仔细一看会发现，比对是在内存中完成中，不涉及到磁盘IO，耗时可以忽略不计。另外B树种一个节点中可以存放很多的key（个数由树阶决定）。
相同数量的key在B树中生成的节点要远远少于二叉树中的节点，相差的节点数量就等同于磁盘IO的次数。这样到达一定数量后，性能的差异就显现出来了。
 三、B树的新增
在刚才的基础上新增元素4，它应该在3与9之间：


四、B树的删除
 删除元素9：
                 

五、总结
　　插入或者删除元素都会导致节点发生裂变反应，有时候会非常麻烦，但正因为如此才让B树能够始终保持多路平衡，这也是B树自身的一个优势：自平衡；B树主要应用于文件系统以及部分数据库索引，如MongoDB，大部分关系型数据库索引则是使用B+树实现。

https://www.cnblogs.com/liuning8023/archive/2012/11/17/2775472.html
##B-tree 
是一种常见的数据结构，也称多路搜索树，并不是二叉树。B-tree 结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。B 通常是 Balance 的简称。该结构一般用于数据库的索引，综合效率较高。B-tree 主要应用在 OLTP 系统（事务方面），而 Bitmap 主要是在 OLAP（分析方面）。


索引块格式化
索引数据的可用空间是 Oracle 数据库的块大小减去块的开销、条目开销、rowid 和每个已索引值的字节长度。

当你创建索引时，Oracle 数据库读取和排序已索引的列，并把 rowid 随每行的索引值一起存储。之后，Oracle 数据库从下往上加载索引。例如，下面语句：

CREATE INDEX employees_last_name ON employees(last_name); 
Oracle 数据库在 employees 表 last_name 列上排序。然后，按已排序的顺序加载带有 last_name 和相应 rowid 值的索引。当使用索引时，Oracle 数据库通过已排序的 last_name 值快速查询，之后，使用与其相关的 rowid 值来定位行。

索引内部结构
Oracle 数据库使用 B-trees 存储索引，来加速数据访问。若没有索引，你必须顺序扫描数据来查找值。对 n 行，检索的平均行数为 n/2。随着数据列的增加，这不能很好地扩展。

一个值的有序列表划分成宽块范围（叶子块），查询时间减少为 log(n)。这是 Oracle 数据库索引的基本原则。

cncpt169

图 1 B-tree 索引的内部结构

b-tree

图 2 B-tree 索引详细内部结构

B-tree 索引的上半部分块（分支块）包含索引数据，并指向低一级的索引块。最低级别的索引块（叶子块）包含每个已索引的数据值和用于定位真实行的相应 rowid。叶子块是双向链接的（双向链表）。包含字符数据的列中索引是基于数据库字符集的字符二进制值。

对于唯一索引，一个 rowid 对每个数据值存在。对于非唯一索引，rowid 按顺序被包含在键中，因此，非唯一索引按索引键和 rowid 排序。不索引包含 null 的键值，除了聚簇索引。两个行可以包含所有 null 值，这不违反唯一索引。

换个简单、更直观的图，如下图所示：

a08b87d6277f9e2fed2005911f30e924b899f316

图 3 B-tree 查询值为 21

说明：

每个节点的值个数，最小有两个，最大有五个，Minimum Degree=2，Maximum Degree=5；
若查找值 21，则会经过 10、20、30，最后到 21。
索引属性
两类数据块：

分支块用来检索
叶子块存储值
分支块（Branch Blocks）
分支块存储如下内容：

最小键的前缀，需要在两个键之间做出分支决定
指向包含键的子块
若数据块具有 n 键，那么它们就有 n+1 个指针。键和指针的数量是由数据块大小限制的。

叶子块（Leaf Blocks）
所有叶子块从 root 到 branch 块都在同一深度。叶子块存储内容如下：

每个行的完整键值
表中每个行的 ROWIDs
所有键和 rowid 都被链接到它们左边和右边的兄弟。它们按键和 rowid 排序。

B-tree 结构的优势
B-tree 结构有如下优势：

树的所有叶子块都在相同深度，这样，在索引中从任何地方检索任何记录都大约花费相同的时间。
B-tree 自动保持平衡。
All blocks of the B-tree are three-quarters full on the average.
B-tree 对大范围查询提供优秀的检索性能，包括精确匹配和访问查询。
插入、更新和删除操作有效，维护键的顺序，以便快速检索。
B-tree 性能对小表和大表都很好，不会随着表的增长而降低。